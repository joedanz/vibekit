import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  QwenConfig,
  QwenResponse,
  QwenStreamCallbacks,
  Conversation,
  ModelProvider,
  AgentType,
} from "../types";

export class QwenAgent extends BaseAgent {
  private qwenApiKey: string;
  private model?: string;
  private provider?: ModelProvider;

  private escapePrompt(prompt: string): string {
    // Escape backticks and other special characters
    return prompt.replace(/[`"$\\]/g, "\\$&");
  }

  constructor(config: QwenConfig) {
    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxProvider: config.sandboxProvider,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      telemetry: config.telemetry,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Validate that provider is compatible with Qwen (OpenAI-compatible only)
    if (config.provider && !["qwen", "openai"].includes(config.provider)) {
      throw new Error(
        "Qwen agent only supports 'qwen' or 'openai' provider (uses OpenAI-compatible API)"
      );
    }

    this.qwenApiKey = config.providerApiKey || "";
    this.model = config.model;
    this.provider = config.provider;
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    return {
      command: `echo "${_prompt}" | qwen --model ${
        this.model || "qwen3-coder-plus"
      } --yolo`,
      errorPrefix: "Qwen",
      labelName: "qwen",
      labelColor: "FF6B35",
      labelDescription: "Generated by Qwen Code AI agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-qwen";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    // Qwen uses OpenAI-compatible API through Alibaba Cloud platforms
    // The specific endpoint is configured via OPENAI_BASE_URL environment variable
    return {
      OPENAI_API_KEY: this.qwenApiKey,
      OPENAI_BASE_URL: "https://dashscope.aliyuncs.com/compatible-mode/v1", // Default endpoint
      OPENAI_MODEL: this.model || "qwen3-coder-plus",
    };
  }

  protected getApiKey(): string {
    return this.qwenApiKey;
  }

  protected getAgentType(): AgentType {
    return "qwen";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: "openai", // Qwen always uses OpenAI-compatible API
      apiKey: this.qwenApiKey,
      model: this.model,
    };
  }

  // Override generateCode to support history in the instruction
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: QwenStreamCallbacks,
    background?: boolean
  ): Promise<QwenResponse> {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    if (history && history.length > 0) {
      instruction += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${h.content}`)
        .join("\n\n")}`;
    }

    const escapedPrompt = this.escapePrompt(prompt);

    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    // Override the command config with history-aware instruction
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `echo "${_prompt}" | qwen --model ${
        this.model || "qwen3-coder-plus"
      } --yolo`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as QwenResponse;
  }
}