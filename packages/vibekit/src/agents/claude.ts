import { BaseAgent, BaseAgentConfig, AgentCommandConfig, ExecuteCommandOptions, AgentResponse, StreamCallbacks } from "./base";
import { ModelConfig } from "./utils";
import {
  AgentType,
  ClaudeConfig,
  ClaudeResponse,
  ClaudeStreamCallbacks,
  Conversation,
  ModelProvider,
  SandboxInstance,
} from "../types";

export class ClaudeAgent extends BaseAgent {
  private anthropicApiKey?: string;
  private oauthToken?: string;
  private model?: string;
  private useOAuth: boolean;
  private tokenInitialized: boolean = false;
  protected declare config: ClaudeConfig;

  private escapePrompt(prompt: string): string {
    // Escape backticks and other special characters
    return prompt.replace(/[`"$\\]/g, "\\$&");
  }

  constructor(config: ClaudeConfig) {
    console.log('[Claude] Agent constructor called with MCP config:', !!config.mcpConfig);
    
    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxProvider: config.sandboxProvider,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      telemetry: config.telemetry,
      workingDirectory: config.workingDirectory,
      mcpConfig: config.mcpConfig,
    };

    super(baseConfig);

    // Validate that provider is anthropic if specified (Claude only supports anthropic)
    if (config.provider && config.provider !== "anthropic") {
      throw new Error("Claude agent only supports 'anthropic' provider");
    }

    // Store config values
    const envOAuthToken = process.env.CLAUDE_CODE_OAUTH_TOKEN;
    this.oauthToken = config.oauthToken || envOAuthToken;
    this.anthropicApiKey = config.providerApiKey;
    this.model = config.model;
    
    // Perform a preliminary check to set useOAuth based on the presence of oauthToken and absence of anthropicApiKey.
    // The final determination of the authentication method is made in initializeToken().
    this.useOAuth = !!(this.oauthToken && !this.anthropicApiKey);
  }
  
  private async initializeToken(): Promise<void> {
    if (this.tokenInitialized) return;
    
    // No automatic OAuth token loading - users must provide tokens themselves
    
    // Determine which auth method to use
    this._determineAuthMethod();
  }

  /**
   * Determines the authentication method to use (OAuth or API key).
   * Sets the `useOAuth` flag based on the available credentials.
   */
  private _determineAuthMethod(): void {
    if (this.oauthToken) {
      this.useOAuth = true;
    } else if (this.anthropicApiKey) {
      this.useOAuth = false;
    } else {
      throw new Error(
        "Claude agent requires either providerApiKey or oauthToken. Run 'vibekit auth claude' to authenticate."
      );
    }
    
    // Validate that at least one auth method is provided
    if (!this.anthropicApiKey && !this.oauthToken) {
      throw new Error(
        "Claude agent requires either providerApiKey or oauthToken. Run 'vibekit auth claude' to authenticate."
      );
    }
    
    this.tokenInitialized = true;
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }
    
    // Add Claude Code system prompt when using OAuth
    if (this.useOAuth) {
      instruction = "You are Claude Code, Anthropic's official CLI for Claude. " + instruction;
    }

    const escapedPrompt = this.escapePrompt(prompt);

    // Run claude from the working directory and explicitly specify the MCP config
    let mcpConfigFlag = "";
    if (this.config.mcpConfig) {
      mcpConfigFlag = ` --mcp-config ${this.WORKING_DIR}/.mcp.json`;
    }
    
    return {
      command: `cd ${this.WORKING_DIR} && echo "${escapedPrompt}" | claude -p --append-system-prompt "${instruction}"${
        mode === "ask" ? ' --disallowedTools "Edit" "Replace" "Write"' : ""
      } --output-format stream-json --verbose${mcpConfigFlag} --model ${
        this.model || "claude-sonnet-4-20250514"
      }`,
      errorPrefix: "Claude",
      labelName: "claude",
      labelColor: "FF6B35",
      labelDescription: "Generated by Claude AI agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-claude";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    const envVars: Record<string, string> = {};
    
    if (this.useOAuth) {
      // For OAuth, pass the token as CLAUDE_CODE_OAUTH_TOKEN
      envVars.CLAUDE_CODE_OAUTH_TOKEN = this.oauthToken!;
    } else {
      // For API key authentication
      envVars.ANTHROPIC_API_KEY = this.anthropicApiKey!;
    }
    
    return envVars;
  }

  protected getApiKey(): string {
    // Return OAuth token if using OAuth, otherwise API key
    return this.useOAuth ? this.oauthToken! : this.anthropicApiKey!;
  }

  protected getAgentType(): AgentType {
    return "claude";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: "anthropic",
      apiKey: this.useOAuth ? this.oauthToken! : this.anthropicApiKey!,
      model: this.model,
    };
  }

  // Override onSandboxReady to set up Claude-specific MCP configuration
  protected async onSandboxReady(sandbox: SandboxInstance): Promise<void> {
    console.log('[Claude] onSandboxReady called');
    await this.setupClaudeMCP(sandbox);
  }

  // Helper method to set up Claude-specific MCP configuration
  private async setupClaudeMCP(sandbox: SandboxInstance): Promise<void> {
    console.log('[Claude] setupClaudeMCP called, hasConfig:', !!this.config.mcpConfig);
    
    if (!this.config.mcpConfig) return;
    
    // Create .mcp.json file in the sandbox for Claude CLI
    const servers = Array.isArray(this.config.mcpConfig.servers)
      ? this.config.mcpConfig.servers
      : [this.config.mcpConfig.servers];
    
    console.log('[Claude] MCP servers:', servers);
      
    const mcpConfig = {
      mcpServers: servers.reduce((acc, server) => {
        if (server.name) {
          acc[server.name] = {
            command: server.command,
            args: server.args || [],
            env: server.env || {}
          };
        }
        return acc;
      }, {} as any)
    };

    const mcpConfigJson = JSON.stringify(mcpConfig, null, 2);
    const base64Config = Buffer.from(mcpConfigJson).toString('base64');
    
    console.log('[Claude] Creating .mcp.json with config:', mcpConfigJson);
    
    try {
      await sandbox.commands.run(
        `echo '${base64Config}' | base64 -d > ${this.WORKING_DIR}/.mcp.json`,
        { timeoutMs: 5000 }
      );
      console.log('[Claude] Created .mcp.json in sandbox for Claude CLI');
    } catch (error) {
      console.warn('[Claude] Failed to create .mcp.json in sandbox:', error);
    }
  }

}
